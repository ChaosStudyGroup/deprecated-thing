var N = null;var searchIndex = {};
searchIndex["sonr"]={"doc":"Simple Oppinionated Networking in Rust","items":[[3,"Token","sonr","Associates readiness notifications with [`Evented`] handles.",N,N],[12,"0","","",0,N],[3,"Ready","","A set of readiness event kinds",N,N],[3,"Event","","An readiness event returned by [`Poll::poll`].",N,N],[3,"Events","","A collection of readiness events.",N,N],[3,"Poll","","Polls for readiness events on all registered values.",N,N],[8,"Evented","","A value that may be registered with `Poll`",N,N],[10,"register","","Register `self` with the given `Poll` instance.",1,[[["self"],["poll"],["token"],["ready"],["pollopt"]],["result",["error"]]]],[10,"reregister","","Re-register `self` with the given `Poll` instance.",1,[[["self"],["poll"],["token"],["ready"],["pollopt"]],["result",["error"]]]],[10,"deregister","","Deregister `self` from the given `Poll` instance",1,[[["self"],["poll"]],["result",["error"]]]],[3,"PreVec","","`PreVec`: a collection that allows inserts at a specific index with an optional offsets. A `PreVec` can be created with either [`capacity`] or [`capacity_with_offset`].",N,N],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"with_capacity","","Create a `PreVec` with a set capacity. Inserting above capacity will either allocate more space or return an error depending on wheter `enable_growth` or `prevent_growth` is called,",2,[[["usize"]],["self"]]],[11,"with_capacity_and_offset","","Create a `PreVec` with a set capacity and offset.",2,[[["usize"],["usize"]],["self"]]],[11,"capacity","","Return the capacity",2,[[["self"]],["usize"]]],[11,"offset","","Return the offset",2,[[["self"]],["usize"]]],[11,"prevent_growth","","Prevent inserting above the capacity.",2,[[["self"]]]],[11,"enable_growth","","Enable the collection to grow and allocate more space.",2,[[["self"]]]],[11,"in_range","","Check if the index is within the range of the collection  (between capacity and offset)",2,[[["self"],["usize"]],["bool"]]],[11,"set_offset","","Set the offset of the collection.",2,[[["self"],["usize"]]]],[11,"get","","Get an entry at a specific index",2,[[["self"],["usize"]],["option"]]],[11,"get_mut","","Get a mutable entry at a specific index",2,[[["self"],["usize"]],["option"]]],[11,"insert","","Insert a value in the next available slot and return the slot index. Inserting above capacity will cause reallocation if and only if the `PreVec` can grow.",2,[[["self"],["t"]],["result",["usize"]]]],[11,"remove","","Remove at index (inserting an empty entry)",2,[[["self"],["usize"]],["option"]]],[11,"len","","Number of occupied slots",2,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the collection has no entries",2,[[["self"]],["bool"]]],[11,"clear","","Remove all entries",2,[[["self"]]]],[11,"index","","",2,[[["self"],["usize"]],["t"]]],[11,"index_mut","","",2,[[["self"],["usize"]],["t"]]],[0,"server","","Servers and listeners",N,N],[3,"Server","sonr::server","A server wraps a listener and accepts incoming connections.",N,N],[5,"tcp_listener","","Create a `TcpListener` from an address and a port.",N,[[["str"],["u16"]],["result",["tcplistener"]]]],[5,"uds_listener","","Create a `UnixListener` for a unix domain socket.",N,[[["str"]],["result",["unixlistener"]]]],[8,"Listener","","Trait for implementing a listener.",N,N],[16,"Stream","","An evented stream, e.g a `TcpStream`",3,N],[10,"accept","","Accept a stream, commonly used by a `Server` instance.",3,[[["self"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new server instance from a listener and a token. The token has to be unique to the `Poll` instance, as no two entities should be registered with the same token.",4,N],[11,"token","","Returns the token used to create the server and register with a `Poll` instance.",4,[[["self"]],["token"]]],[11,"accept","","Accept incoming connections",4,[[["self"]],["result"]]],[11,"listen","","Listen for incoming connections. Should only be called once",4,[[["self"]],["result"]]],[0,"connections","sonr","Connections and Sessions",N,N],[3,"TcpConnection","sonr::connections","Tcp connection. ``` # use std::time::Duration; # use sonr::{Poll, Ready, Token, Events}; # use sonr::errors::Result; use std::io::{Read, Write}; use sonr::connections::{Connection, TcpConnection};",N,N],[3,"UdsConnection","","Uds connection. ``` # use std::time::Duration; # use sonr::{Poll, Ready, Token, Events}; # use sonr::errors::Result; use std::io::{Read, Write}; use sonr::connections::{Connection, UdsConnection};",N,N],[3,"Sessions","","`Sessions` handles multiple connections.",N,N],[3,"Session","","Unlike a connection the session has an internal buffer.",N,N],[3,"EventReader","","Handle reading data from the underlying connection of a [`Session`].",N,N],[3,"EventWriter","","Handle writing data to the underlying connection of a [`Session`].",N,N],[3,"Connections","","A collection of connections. It's recommended to use [`Sessions`] unless the functionality is not covered by [`Sessions`].",N,N],[4,"EventResult","","A result of a `read_buf` or `write_buf` call on a session.",N,N],[13,"Ok","","Number of bytes that was successfully read or written",5,N],[13,"ConnectionRemoved","","The connection can no longer write / read",5,N],[13,"Retry","","The event is blocking and should be retried. This will happen on the next attempt at writing or reading and no special action is required",5,N],[13,"NoEvent","","There was no write or read event.",5,N],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `TcpConnection` from a `TcpStream`",6,[[["tcpstream"]],["self"]]],[11,"connect_with","","Tries to connect to an address",6,[[["t"]],["result"]]],[11,"connect","","Tries to connect to an address & port",6,[[["str"],["u16"]],["result"]]],[11,"peer_addr","","Return the peer address",6,[[["self"]],["result",["socketaddr"]]]],[11,"register","","",6,[[["self"],["poll"],["t"]],["result"]]],[11,"reregister","","",6,[[["self"],["poll"],["t"]],["result"]]],[11,"interest","","",6,[[["self"]],["ready"]]],[11,"read","","",6,N],[11,"write","","",6,N],[11,"flush","","",6,[[["self"]],["result"]]],[11,"from","","",6,[[["tcpstream"]],["self"]]],[11,"as_mut","","",6,[[["self"]],["self"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"new","","Create a new `UdsConnection` from a unix stream",7,[[["unixstream"]],["udsconnection"]]],[11,"connect","","Connect to a given path",7,[[["p"]],["result",["udsconnection"]]]],[11,"register","","",7,[[["self"],["poll"],["t"]],["result"]]],[11,"reregister","","",7,[[["self"],["poll"],["t"]],["result"]]],[11,"interest","","",7,[[["self"]],["ready"]]],[11,"read","","",7,N],[11,"write","","",7,N],[11,"flush","","",7,[[["self"]],["result"]]],[11,"from","","",7,[[["unixstream"]],["self"]]],[11,"new","","Create a new session from a connection",8,[[["c"]],["self"]]],[11,"with_capacity","","Create a new session with the capacity for the internal buffer",8,[[["c"],["usize"]],["self"]]],[11,"slice","","Expose a slice of the internal buffer with data from the  last `fill_buffer` call. The buffer will be empty until `fill_buffer` is called",8,N],[11,"write_buf","","Write data into a slice. Call this on an event with `event.readiness().is_writable()` or the call will block If the `Session` is handled outside of [`Sessions`] then make sure that: *  The token is the same token as the session was registered with. *  The session doesn't try to read / write again in the case of a `WriteResult::ConnectionRemoved`",8,N],[11,"read_buf","","Read data into the internal buffer. Call this on an event with `event.readiness().is_readable()`. Calling this when the `Session` is not registered as readable or the token doesn't match the token the `Session` was registered with, will block.",8,[[["self"],["poll"],["token"]],["eventresult"]]],[11,"register_writable","","Register the underlying connection as writable. Either `register_readable` or `register_writable` should be called, and only once.",8,[[["self"],["poll"],["token"]],["result"]]],[11,"register_readable","","Register the underlying connection as readable. See [`register_writable`] as the same information applies",8,[[["self"],["poll"],["token"]],["result"]]],[11,"reregister_writable","","Reregister the underlying connection as writable. Unlike [`register_readable`] and [`register_writable`], `reregister` can be called multiple times.",8,[[["self"],["poll"],["token"]],["result"]]],[11,"reregister_readable","","Reregister the underlying connection as readable. See [`register_writable`] as same information applies, excpet  for reading rather than writing to the underlying connection.",8,[[["self"],["poll"],["token"]],["result"]]],[11,"with_capacity","","Create a `Session` with a max number of connections. `Sessions` are built on top of a [`PreVec`] which prevents growth by default. This is to ensure that two `Sessions` don't overlap.",9,[[["usize"]],["self"]]],[11,"with_capacity_and_offset","","Create a `Session` with a max number of connections and a connection offset. This is useful in the event of multiple `Sessions` objects being registered with the same `Poll` handle.",9,[[["usize"],["usize"]],["self"]]],[11,"add","","Add a `Session` and register it with the `poll` handle. The `Session` is neither listening for read or write events at this point.",9,[[["self"],["poll"],["session"]],["result"]]],[11,"remove","","Remove and subsequently close the `Session` and underlying connection. It is safe to call remove multiple times.",9,[[["self"],["t"]]]],[11,"get_mut","","Get a mutable reference to a `Session`",9,[[["self"],["t"]],["option",["session"]]]],[11,"reregister_writable","","Reregister the underlying connection as writable. Calling `reregister_writable` will reregister interest for write events with the `Poll` handle.",9,[[["self"],["poll"],["token"]],["result"]]],[11,"reregister_readable","","Register the underlying connection as readable. Calling `reregister_readable` will reregister interest for read events with the `Poll` handle.",9,[[["self"],["poll"],["token"]],["result"]]],[11,"try_read","","Try to read from the underlying connection matching the token of the event. It's safe to call `try_read` without checking whether the event is readable or not as this will be checked before reading. In the event of calling `try_read` on an event that is not readable, the [`EventReader`] will return `ReadResult::NoEvent`.",9,[[["self"],["poll"],["event"]],["eventreader"]]],[11,"try_write","","Try to write to the underlying connection matching the token of the event. Like `try_read` it's safe to call without checking if the event is writable.",9,[[["self"],["poll"],["event"]],["eventwriter"]]],[11,"and_then","","Calls provided closure with a byte slice containing the data read from the socket.",10,[[["self"],["f"]],["done"]]],[11,"with","","Provides a slice (`&[u8]`) to write to the underlying connection.",11,[[["self"],["f"]],["done"]]],[11,"index","","",9,N],[11,"index_mut","","",9,[[["self"],["t"]],["session"]]],[8,"Connection","","A trait representing a connection.",N,N],[10,"register","","Register interest with the `poll` handle",12,[[["self"],["poll"],["t"]],["result"]]],[10,"reregister","","Reregister interest with the `poll` handle",12,[[["self"],["poll"],["t"]],["result"]]],[10,"interest","","Current interest (read and or write) assigned  to the connection",12,[[["self"]],["ready"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"with_capacity","","Creates a non-growable collection of `T: Connection`s. If more control is required than what is available in [`Sessions`] then use `Connections`.",13,[[["usize"]],["self"]]],[11,"insert_and_register","","Insert and register a new connection. As with [`Sessions`] the read / write interest will be absent until the connection is reregistered with either read and / or write.",13,[[["self"],["poll"],["t"]],["result"]]],[11,"reregister","","Reregister the interest of the connection.",13,[[["self"],["poll"],["token"]],["result"]]],[11,"get","","Get a reference to a [`T: Connection`]",13,[[["self"],["u"]],["option"]]],[11,"get_mut","","Get a mutable reference to a [`T: Connection`]",13,[[["self"],["u"]],["option"]]],[11,"len","","Number of connections",13,[[["self"]],["usize"]]],[11,"is_empty","","Whether there are connections or not",13,[[["self"]],["bool"]]],[11,"read","","Read from a connection into a buffer (`&[u8]`) returning number of bytes read if successful.",13,N],[11,"write","","Write to a connection returning number of bytes written if successful.",13,N],[11,"index","","",13,N],[11,"index_mut","","",13,[[["self"],["t"]],["c"]]],[0,"errors","sonr","SONR default `Error`",N,N],[4,"Error","sonr::errors","Wrapping error type.",N,N],[13,"Io","","std::io::Error",14,N],[13,"NoConnection","","No connection: A connection with a specific `Token` no longer exists",14,N],[13,"ConnectionRemoved","","The connection was removed either by closing the socket or through a socket error",14,N],[13,"NoCapacity","","The `PreVec` does not have capacity for the new entry",14,N],[13,"AlreadyRegistered","","The session was already registered. A session can only be registered once (but reregistered multiple times)",14,N],[6,"Result","","Result type: `std::result::Error<T, Error>`",N,N],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"from","","",14,[[["error"]],["error"]]],[11,"to_owned","sonr","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"into_iter","","",15,N],[11,"bitor_assign","","",16,N],[11,"bitand_assign","","",16,N],[11,"bitxor_assign","","",16,N],[11,"from","","",0,[[["usize"]],["token"]]],[11,"from","","",16,[[["unixready"]],["ready"]]],[11,"partial_cmp","","",16,[[["self"],["ready"]],["option",["ordering"]]]],[11,"lt","","",16,[[["self"],["ready"]],["bool"]]],[11,"le","","",16,[[["self"],["ready"]],["bool"]]],[11,"gt","","",16,[[["self"],["ready"]],["bool"]]],[11,"ge","","",16,[[["self"],["ready"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["token"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["token"]],["bool"]]],[11,"le","","",0,[[["self"],["token"]],["bool"]]],[11,"gt","","",0,[[["self"],["token"]],["bool"]]],[11,"ge","","",0,[[["self"],["token"]],["bool"]]],[11,"sub","","",16,[[["self"],["t"]],["ready"]]],[11,"cmp","","",0,[[["self"],["token"]],["ordering"]]],[11,"cmp","","",16,[[["self"],["ready"]],["ordering"]]],[11,"eq","","",17,[[["self"],["event"]],["bool"]]],[11,"ne","","",17,[[["self"],["event"]],["bool"]]],[11,"eq","","",16,[[["self"],["ready"]],["bool"]]],[11,"ne","","",16,[[["self"],["ready"]],["bool"]]],[11,"eq","","",0,[[["self"],["token"]],["bool"]]],[11,"ne","","",0,[[["self"],["token"]],["bool"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result",["error"]]]],[11,"empty","","Returns the empty `Ready` set.",16,[[],["ready"]]],[11,"readable","","Returns a `Ready` representing readable readiness.",16,[[],["ready"]]],[11,"writable","","Returns a `Ready` representing writable readiness.",16,[[],["ready"]]],[11,"all","","Returns a `Ready` representing readiness for all operations.",16,[[],["ready"]]],[11,"is_empty","","Returns true if `Ready` is the empty set",16,[[["self"]],["bool"]]],[11,"is_readable","","Returns true if the value includes readable readiness",16,[[["self"]],["bool"]]],[11,"is_writable","","Returns true if the value includes writable readiness",16,[[["self"]],["bool"]]],[11,"insert","","Adds all readiness represented by `other` into `self`.",16,N],[11,"remove","","Removes all options represented by `other` from `self`.",16,N],[11,"contains","","Returns true if `self` is a superset of `other`.",16,[[["self"],["t"]],["bool"]]],[11,"from_usize","","Create a `Ready` instance using the given `usize` representation.",16,[[["usize"]],["ready"]]],[11,"as_usize","","Returns a `usize` representation of the `Ready` value.",16,[[["self"]],["usize"]]],[11,"bitxor","","",16,[[["self"],["t"]],["ready"]]],[11,"hash","","",0,N],[11,"sub_assign","","",16,N],[11,"clone","","",16,[[["self"]],["ready"]]],[11,"clone","","",0,[[["self"]],["token"]]],[11,"clone","","",17,[[["self"]],["event"]]],[11,"bitand","","",16,[[["self"],["t"]],["ready"]]],[11,"as_raw_fd","","",18,[[["self"]],["i32"]]],[11,"bitor","","",16,[[["self"],["t"]],["ready"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"new","","Creates a new `Event` containing `readiness` and `token`",17,[[["ready"],["token"]],["event"]]],[11,"readiness","","Returns the event's readiness.",17,[[["self"]],["ready"]]],[11,"token","","Returns the event's token.",17,[[["self"]],["token"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"with_capacity","","Return a new `Events` capable of holding up to `capacity` events.",15,[[["usize"]],["events"]]],[11,"capacity","","Returns the number of `Event` values that `self` can hold.",15,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if `self` contains no `Event` values.",15,[[["self"]],["bool"]]],[11,"iter","","Returns an iterator over the `Event` values.",15,[[["self"]],["iter"]]],[11,"clear","","Clearing all `Event` values from container explicitly.",15,N],[11,"from","","",15,[[["t"]],["t"]]],[11,"into_iter","","",15,[[["self"]],["i"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"new","","Return a new `Poll` handle.",18,[[],["result",["poll","error"]]]],[11,"register","","Register an `Evented` handle with the `Poll` instance.",18,[[["self"],["e"],["token"],["ready"],["pollopt"]],["result",["error"]]]],[11,"reregister","","Re-register an `Evented` handle with the `Poll` instance.",18,[[["self"],["e"],["token"],["ready"],["pollopt"]],["result",["error"]]]],[11,"deregister","","Deregister an `Evented` handle with the `Poll` instance.",18,[[["self"],["e"]],["result",["error"]]]],[11,"poll","","Wait for readiness events",18,[[["self"],["events"],["option",["duration"]]],["result",["usize","error"]]]],[11,"poll_interruptible","","Like `poll`, but may be interrupted by a signal",18,[[["self"],["events"],["option",["duration"]]],["result",["usize","error"]]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","sonr::server","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","sonr::connections","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","sonr::errors","",14,[[["t"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]]],"paths":[[3,"Token"],[8,"Evented"],[3,"PreVec"],[8,"Listener"],[3,"Server"],[4,"EventResult"],[3,"TcpConnection"],[3,"UdsConnection"],[3,"Session"],[3,"Sessions"],[3,"EventReader"],[3,"EventWriter"],[8,"Connection"],[3,"Connections"],[4,"Error"],[3,"Events"],[3,"Ready"],[3,"Event"],[3,"Poll"]]};
initSearch(searchIndex);
